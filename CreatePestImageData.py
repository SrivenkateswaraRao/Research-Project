# -*- coding: utf-8 -*-
"""createImageDataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FXiYKCQ-jtbL_O29BQb2Xy1bBd2inM9q
"""

from os import listdir
import numpy as np
import xml.etree.ElementTree as ET
import cv2
import tensorflow as tf 

class createImageDataset(object):
    
    def __init__(self, class_map=None):
        self.image_info = []
        self.trainX = []
        self.trainY = []
        self.testX = []
        self.testY = []
            
    def add_image_info(self , image_array , image_path , image_id , object_id , class_name , class_id):
        
        image_info_ = {'object_id': image_id,
                       'object_class': class_name,
                       'image_path': image_path,
                       'image_array': image_array,
                       'class_id' : class_id}
        self.image_info.append(image_info_)

    def parse_xml(self,filer):
        boxes = list()
        names = list()
        root = ET.parse(filer).getroot() 
        for box in root.findall('.//object'):
            xmin = int(box.find('.//bndbox/xmin').text)
            xmax = int(box.find('.//bndbox/xmax').text)
            ymin = int(box.find('.//bndbox/ymin').text)
            ymax = int(box.find('.//bndbox/ymax').text)
            name = box.find('.//name').text
            coords = [xmin , ymin , xmax , ymax]
            names.append(name)
            boxes.append(coords)
        width = int(root.find('.//size/width').text)
        height = int(root.find('.//size/height').text)
        path = root.find('.//path').text
        filename = root.find('filename').text
        filename = filename[:-4]

        return boxes, width, height , names , path , filename

    def get_image_arrays(self , annot_path , class_object, img_Size, imageFilePath):
        
        count = 0
        for i in listdir(annot_path):
            patt = annot_path +'/' + i
            parsed = self.parse_xml(patt)
            img = cv2.imread(imageFilePath + '/' + i[0:-4] + '.jpg')
            for wh in range(0 , len(parsed[0])):
                crop_img = img[parsed[0][wh][1]:parsed[0][wh][3] , parsed[0][wh][0]:parsed[0][wh][2] ]
                
                class_name = parsed[3][wh]
                keys = list(class_object.keys())  
                values = list(class_object.values())
                class_id = keys[values.index(class_name)]
                
                try:  
                    if np.shape(crop_img) != ():
                       resized_img = cv2.resize(crop_img,(img_Size,img_Size))
                       self.add_image_info( image_array = resized_img , image_path = parsed[4],
                                   object_id = count , class_name=parsed[3][wh] , image_id= 0 , class_id=class_id )
                       print('Image : ' + parsed[4] + ' added to dataset with class name "' + parsed[3][wh]  +'".'  )
                    else:
                       print('Image : ' + parsed[4] + ' Failed to be added to the  dataset with class name "' + parsed[3][wh]  +'".'  )  
                except Exception as e:  
                     print(str(e))                
                count = count + 1
    
    def prepare_dataset(self , path , class_object , image_Size, imagePath, test_size):
        
        self.get_image_arrays(path , class_object, image_Size, imagePath)
        
        img_arrays = np.array([d['image_array'] for d in self.image_info if 'image_array' in d])
        class_names = np.array([d['object_class'] for d in self.image_info if 'object_class' in d])
        class_ids  = np.array([d['class_id'] for d in self.image_info if 'class_id' in d])
        all_idx = range(0 , len(img_arrays))
        test_idx = np.random.choice(np.arange(len(img_arrays)), test_size, replace=False)
        train_idx = np.delete(all_idx , test_idx) 
        
        
        self.testX = img_arrays[test_idx]
        self.testY = class_ids[test_idx]
        
        self.trainX = img_arrays[train_idx]        
        self.trainY = class_ids[train_idx]
        
        return print('Image dataset succesfully saved.')